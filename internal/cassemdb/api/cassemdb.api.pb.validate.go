// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: cassemdb.cassemagent.api.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
)

// Validate checks the field values on Entity with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Entity) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Fingerprint

	// no validation rules for Key

	// no validation rules for Val

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for Ttl

	// no validation rules for Typ

	return nil
}

// EntityValidationError is the validation error returned by Entity.Validate if
// the designated constraints aren't met.
type EntityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityValidationError) ErrorName() string { return "EntityValidationError" }

// Error satisfies the builtin error interface
func (e EntityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityValidationError{}

// Validate checks the field values on Change with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Change) Validate() error {
	if m == nil {
		return nil
	}

	if _, ok := Change_ChangeOp_name[int32(m.GetOp())]; !ok {
		return ChangeValidationError{
			field:  "Op",
			reason: "value must be one of the defined enum values",
		}
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		return ChangeValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
	}

	if !strings.Contains(m.GetKey(), "/") {
		return ChangeValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
	}

	if v, ok := interface{}(m.GetLast()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeValidationError{
				field:  "Last",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ChangeValidationError is the validation error returned by Change.Validate if
// the designated constraints aren't met.
type ChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeValidationError) ErrorName() string { return "ChangeValidationError" }

// Error satisfies the builtin error interface
func (e ChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeValidationError{}

// Validate checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Empty) Validate() error {
	if m == nil {
		return nil
	}

	return nil
}

// EmptyValidationError is the validation error returned by Empty.Validate if
// the designated constraints aren't met.
type EmptyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyValidationError) ErrorName() string { return "EmptyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmpty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyValidationError{}

// Validate checks the field values on GetKVReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *GetKVReq) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		return GetKVReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
	}

	if !strings.Contains(m.GetKey(), "/") {
		return GetKVReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
	}

	return nil
}

// GetKVReqValidationError is the validation error returned by
// GetKVReq.Validate if the designated constraints aren't met.
type GetKVReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVReqValidationError) ErrorName() string { return "GetKVReqValidationError" }

// Error satisfies the builtin error interface
func (e GetKVReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVReqValidationError{}

// Validate checks the field values on GetKVResp with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *GetKVResp) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetEntity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetKVRespValidationError{
				field:  "Entity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// GetKVRespValidationError is the validation error returned by
// GetKVResp.Validate if the designated constraints aren't met.
type GetKVRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVRespValidationError) ErrorName() string { return "GetKVRespValidationError" }

// Error satisfies the builtin error interface
func (e GetKVRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVRespValidationError{}

// Validate checks the field values on GetKVsReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *GetKVsReq) Validate() error {
	if m == nil {
		return nil
	}

	if l := len(m.GetKeys()); l < 1 || l > 100 {
		return GetKVsReqValidationError{
			field:  "Keys",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
	}

	_GetKVsReq_Keys_Unique := make(map[string]struct{}, len(m.GetKeys()))

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if _, exists := _GetKVsReq_Keys_Unique[item]; exists {
			return GetKVsReqValidationError{
				field:  fmt.Sprintf("Keys[%v]", idx),
				reason: "repeated value must contain unique items",
			}
		} else {
			_GetKVsReq_Keys_Unique[item] = struct{}{}
		}

		// no validation rules for Keys[idx]
	}

	return nil
}

// GetKVsReqValidationError is the validation error returned by
// GetKVsReq.Validate if the designated constraints aren't met.
type GetKVsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVsReqValidationError) ErrorName() string { return "GetKVsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetKVsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVsReqValidationError{}

// Validate checks the field values on GetKVsResp with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *GetKVsResp) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetKVsRespValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// GetKVsRespValidationError is the validation error returned by
// GetKVsResp.Validate if the designated constraints aren't met.
type GetKVsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVsRespValidationError) ErrorName() string { return "GetKVsRespValidationError" }

// Error satisfies the builtin error interface
func (e GetKVsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVsRespValidationError{}

// Validate checks the field values on SetKVReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *SetKVReq) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		return SetKVReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
	}

	if !strings.Contains(m.GetKey(), "/") {
		return SetKVReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
	}

	// no validation rules for IsDir

	// no validation rules for Ttl

	if l := len(m.GetVal()); l < 1 || l > 262144 {
		return SetKVReqValidationError{
			field:  "Val",
			reason: "value length must be between 1 and 262144 bytes, inclusive",
		}
	}

	// no validation rules for Overwrite

	return nil
}

// SetKVReqValidationError is the validation error returned by
// SetKVReq.Validate if the designated constraints aren't met.
type SetKVReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetKVReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetKVReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetKVReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetKVReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetKVReqValidationError) ErrorName() string { return "SetKVReqValidationError" }

// Error satisfies the builtin error interface
func (e SetKVReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetKVReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetKVReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetKVReqValidationError{}

// Validate checks the field values on UnsetKVReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *UnsetKVReq) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		return UnsetKVReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
	}

	// no validation rules for IsDir

	return nil
}

// UnsetKVReqValidationError is the validation error returned by
// UnsetKVReq.Validate if the designated constraints aren't met.
type UnsetKVReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnsetKVReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnsetKVReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnsetKVReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnsetKVReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnsetKVReqValidationError) ErrorName() string { return "UnsetKVReqValidationError" }

// Error satisfies the builtin error interface
func (e UnsetKVReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnsetKVReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnsetKVReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnsetKVReqValidationError{}

// Validate checks the field values on WatchReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *WatchReq) Validate() error {
	if m == nil {
		return nil
	}

	if l := len(m.GetKeys()); l < 1 || l > 20 {
		return WatchReqValidationError{
			field:  "Keys",
			reason: "value must contain between 1 and 20 items, inclusive",
		}
	}

	_WatchReq_Keys_Unique := make(map[string]struct{}, len(m.GetKeys()))

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if _, exists := _WatchReq_Keys_Unique[item]; exists {
			return WatchReqValidationError{
				field:  fmt.Sprintf("Keys[%v]", idx),
				reason: "repeated value must contain unique items",
			}
		} else {
			_WatchReq_Keys_Unique[item] = struct{}{}
		}

		// no validation rules for Keys[idx]
	}

	return nil
}

// WatchReqValidationError is the validation error returned by
// WatchReq.Validate if the designated constraints aren't met.
type WatchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchReqValidationError) ErrorName() string { return "WatchReqValidationError" }

// Error satisfies the builtin error interface
func (e WatchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchReqValidationError{}

// Validate checks the field values on TtlReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *TtlReq) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		return TtlReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
	}

	if !strings.Contains(m.GetKey(), "/") {
		return TtlReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
	}

	return nil
}

// TtlReqValidationError is the validation error returned by TtlReq.Validate if
// the designated constraints aren't met.
type TtlReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TtlReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TtlReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TtlReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TtlReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TtlReqValidationError) ErrorName() string { return "TtlReqValidationError" }

// Error satisfies the builtin error interface
func (e TtlReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTtlReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TtlReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TtlReqValidationError{}

// Validate checks the field values on TtlResp with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *TtlResp) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Ttl

	return nil
}

// TtlRespValidationError is the validation error returned by TtlResp.Validate
// if the designated constraints aren't met.
type TtlRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TtlRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TtlRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TtlRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TtlRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TtlRespValidationError) ErrorName() string { return "TtlRespValidationError" }

// Error satisfies the builtin error interface
func (e TtlRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTtlResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TtlRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TtlRespValidationError{}

// Validate checks the field values on ExpireReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *ExpireReq) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		return ExpireReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
	}

	if !strings.Contains(m.GetKey(), "/") {
		return ExpireReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
	}

	return nil
}

// ExpireReqValidationError is the validation error returned by
// ExpireReq.Validate if the designated constraints aren't met.
type ExpireReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpireReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpireReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpireReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpireReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpireReqValidationError) ErrorName() string { return "ExpireReqValidationError" }

// Error satisfies the builtin error interface
func (e ExpireReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpireReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpireReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpireReqValidationError{}

// Validate checks the field values on RangeReq with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *RangeReq) Validate() error {
	if m == nil {
		return nil
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		return RangeReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
	}

	if m.GetSeek() != "" {

		if utf8.RuneCountInString(m.GetSeek()) < 1 {
			return RangeReqValidationError{
				field:  "Seek",
				reason: "value length must be at least 1 runes",
			}
		}

	}

	if val := m.GetLimit(); val < 1 || val > 100 {
		return RangeReqValidationError{
			field:  "Limit",
			reason: "value must be inside range [1, 100]",
		}
	}

	return nil
}

// RangeReqValidationError is the validation error returned by
// RangeReq.Validate if the designated constraints aren't met.
type RangeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeReqValidationError) ErrorName() string { return "RangeReqValidationError" }

// Error satisfies the builtin error interface
func (e RangeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeReqValidationError{}

// Validate checks the field values on RangeResp with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *RangeResp) Validate() error {
	if m == nil {
		return nil
	}

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RangeRespValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for HasMore

	// no validation rules for NextSeekKey

	return nil
}

// RangeRespValidationError is the validation error returned by
// RangeResp.Validate if the designated constraints aren't met.
type RangeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeRespValidationError) ErrorName() string { return "RangeRespValidationError" }

// Error satisfies the builtin error interface
func (e RangeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeRespValidationError{}
