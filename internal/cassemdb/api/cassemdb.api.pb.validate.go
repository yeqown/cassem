// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: cassemdb.api.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Entity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Entity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Entity with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EntityMultiError, or nil if none found.
func (m *Entity) ValidateAll() error {
	return m.validate(true)
}

func (m *Entity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Fingerprint

	// no validation rules for Key

	// no validation rules for Val

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for Ttl

	// no validation rules for Typ

	// no validation rules for Size

	if len(errors) > 0 {
		return EntityMultiError(errors)
	}
	return nil
}

// EntityMultiError is an error wrapping multiple validation errors returned by
// Entity.ValidateAll() if the designated constraints aren't met.
type EntityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMultiError) AllErrors() []error { return m }

// EntityValidationError is the validation error returned by Entity.Validate if
// the designated constraints aren't met.
type EntityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityValidationError) ErrorName() string { return "EntityValidationError" }

// Error satisfies the builtin error interface
func (e EntityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityValidationError{}

// Validate checks the field values on Change with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Change) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Change with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ChangeMultiError, or nil if none found.
func (m *Change) ValidateAll() error {
	return m.validate(true)
}

func (m *Change) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := Change_Op_name[int32(m.GetOp())]; !ok {
		err := ChangeValidationError{
			field:  "Op",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		err := ChangeValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.Contains(m.GetKey(), "/") {
		err := ChangeValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetLast()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeValidationError{
					field:  "Last",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeValidationError{
					field:  "Last",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLast()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeValidationError{
				field:  "Last",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeValidationError{
				field:  "Current",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChangeMultiError(errors)
	}
	return nil
}

// ChangeMultiError is an error wrapping multiple validation errors returned by
// Change.ValidateAll() if the designated constraints aren't met.
type ChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeMultiError) AllErrors() []error { return m }

// ChangeValidationError is the validation error returned by Change.Validate if
// the designated constraints aren't met.
type ChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeValidationError) ErrorName() string { return "ChangeValidationError" }

// Error satisfies the builtin error interface
func (e ChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeValidationError{}

// Validate checks the field values on ParentDirectoryChange with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParentDirectoryChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParentDirectoryChange with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParentDirectoryChangeMultiError, or nil if none found.
func (m *ParentDirectoryChange) ValidateAll() error {
	return m.validate(true)
}

func (m *ParentDirectoryChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParentDirectoryChangeValidationError{
					field:  "Change",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParentDirectoryChangeValidationError{
					field:  "Change",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParentDirectoryChangeValidationError{
				field:  "Change",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SpecificTopic

	if len(errors) > 0 {
		return ParentDirectoryChangeMultiError(errors)
	}
	return nil
}

// ParentDirectoryChangeMultiError is an error wrapping multiple validation
// errors returned by ParentDirectoryChange.ValidateAll() if the designated
// constraints aren't met.
type ParentDirectoryChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParentDirectoryChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParentDirectoryChangeMultiError) AllErrors() []error { return m }

// ParentDirectoryChangeValidationError is the validation error returned by
// ParentDirectoryChange.Validate if the designated constraints aren't met.
type ParentDirectoryChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParentDirectoryChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParentDirectoryChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParentDirectoryChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParentDirectoryChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParentDirectoryChangeValidationError) ErrorName() string {
	return "ParentDirectoryChangeValidationError"
}

// Error satisfies the builtin error interface
func (e ParentDirectoryChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParentDirectoryChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParentDirectoryChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParentDirectoryChangeValidationError{}

// Validate checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Empty) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Empty with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmptyMultiError, or nil if none found.
func (m *Empty) ValidateAll() error {
	return m.validate(true)
}

func (m *Empty) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyMultiError(errors)
	}
	return nil
}

// EmptyMultiError is an error wrapping multiple validation errors returned by
// Empty.ValidateAll() if the designated constraints aren't met.
type EmptyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyMultiError) AllErrors() []error { return m }

// EmptyValidationError is the validation error returned by Empty.Validate if
// the designated constraints aren't met.
type EmptyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyValidationError) ErrorName() string { return "EmptyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmpty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyValidationError{}

// Validate checks the field values on GetKVReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetKVReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKVReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetKVReqMultiError, or nil
// if none found.
func (m *GetKVReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKVReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		err := GetKVReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.Contains(m.GetKey(), "/") {
		err := GetKVReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetKVReqMultiError(errors)
	}
	return nil
}

// GetKVReqMultiError is an error wrapping multiple validation errors returned
// by GetKVReq.ValidateAll() if the designated constraints aren't met.
type GetKVReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKVReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKVReqMultiError) AllErrors() []error { return m }

// GetKVReqValidationError is the validation error returned by
// GetKVReq.Validate if the designated constraints aren't met.
type GetKVReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVReqValidationError) ErrorName() string { return "GetKVReqValidationError" }

// Error satisfies the builtin error interface
func (e GetKVReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVReqValidationError{}

// Validate checks the field values on GetKVResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetKVResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKVResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetKVRespMultiError, or nil
// if none found.
func (m *GetKVResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKVResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetKVRespValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetKVRespValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetKVRespValidationError{
				field:  "Entity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetKVRespMultiError(errors)
	}
	return nil
}

// GetKVRespMultiError is an error wrapping multiple validation errors returned
// by GetKVResp.ValidateAll() if the designated constraints aren't met.
type GetKVRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKVRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKVRespMultiError) AllErrors() []error { return m }

// GetKVRespValidationError is the validation error returned by
// GetKVResp.Validate if the designated constraints aren't met.
type GetKVRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVRespValidationError) ErrorName() string { return "GetKVRespValidationError" }

// Error satisfies the builtin error interface
func (e GetKVRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVRespValidationError{}

// Validate checks the field values on GetKVsReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetKVsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKVsReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetKVsReqMultiError, or nil
// if none found.
func (m *GetKVsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKVsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetKeys()); l < 1 || l > 100 {
		err := GetKVsReqValidationError{
			field:  "Keys",
			reason: "value must contain between 1 and 100 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_GetKVsReq_Keys_Unique := make(map[string]struct{}, len(m.GetKeys()))

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if _, exists := _GetKVsReq_Keys_Unique[item]; exists {
			err := GetKVsReqValidationError{
				field:  fmt.Sprintf("Keys[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_GetKVsReq_Keys_Unique[item] = struct{}{}
		}

		// no validation rules for Keys[idx]
	}

	if len(errors) > 0 {
		return GetKVsReqMultiError(errors)
	}
	return nil
}

// GetKVsReqMultiError is an error wrapping multiple validation errors returned
// by GetKVsReq.ValidateAll() if the designated constraints aren't met.
type GetKVsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKVsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKVsReqMultiError) AllErrors() []error { return m }

// GetKVsReqValidationError is the validation error returned by
// GetKVsReq.Validate if the designated constraints aren't met.
type GetKVsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVsReqValidationError) ErrorName() string { return "GetKVsReqValidationError" }

// Error satisfies the builtin error interface
func (e GetKVsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVsReqValidationError{}

// Validate checks the field values on GetKVsResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetKVsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetKVsResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetKVsRespMultiError, or
// nil if none found.
func (m *GetKVsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetKVsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetKVsRespValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetKVsRespValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetKVsRespValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetKVsRespMultiError(errors)
	}
	return nil
}

// GetKVsRespMultiError is an error wrapping multiple validation errors
// returned by GetKVsResp.ValidateAll() if the designated constraints aren't met.
type GetKVsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetKVsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetKVsRespMultiError) AllErrors() []error { return m }

// GetKVsRespValidationError is the validation error returned by
// GetKVsResp.Validate if the designated constraints aren't met.
type GetKVsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetKVsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetKVsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetKVsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetKVsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetKVsRespValidationError) ErrorName() string { return "GetKVsRespValidationError" }

// Error satisfies the builtin error interface
func (e GetKVsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetKVsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetKVsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetKVsRespValidationError{}

// Validate checks the field values on SetKVReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetKVReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetKVReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetKVReqMultiError, or nil
// if none found.
func (m *SetKVReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetKVReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		err := SetKVReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.Contains(m.GetKey(), "/") {
		err := SetKVReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsDir

	// no validation rules for Ttl

	if l := len(m.GetVal()); l < 0 || l > 262144 {
		err := SetKVReqValidationError{
			field:  "Val",
			reason: "value length must be between 0 and 262144 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Overwrite

	if len(errors) > 0 {
		return SetKVReqMultiError(errors)
	}
	return nil
}

// SetKVReqMultiError is an error wrapping multiple validation errors returned
// by SetKVReq.ValidateAll() if the designated constraints aren't met.
type SetKVReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetKVReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetKVReqMultiError) AllErrors() []error { return m }

// SetKVReqValidationError is the validation error returned by
// SetKVReq.Validate if the designated constraints aren't met.
type SetKVReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetKVReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetKVReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetKVReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetKVReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetKVReqValidationError) ErrorName() string { return "SetKVReqValidationError" }

// Error satisfies the builtin error interface
func (e SetKVReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetKVReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetKVReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetKVReqValidationError{}

// Validate checks the field values on UnsetKVReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnsetKVReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnsetKVReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnsetKVReqMultiError, or
// nil if none found.
func (m *UnsetKVReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UnsetKVReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		err := UnsetKVReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsDir

	if len(errors) > 0 {
		return UnsetKVReqMultiError(errors)
	}
	return nil
}

// UnsetKVReqMultiError is an error wrapping multiple validation errors
// returned by UnsetKVReq.ValidateAll() if the designated constraints aren't met.
type UnsetKVReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnsetKVReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnsetKVReqMultiError) AllErrors() []error { return m }

// UnsetKVReqValidationError is the validation error returned by
// UnsetKVReq.Validate if the designated constraints aren't met.
type UnsetKVReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnsetKVReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnsetKVReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnsetKVReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnsetKVReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnsetKVReqValidationError) ErrorName() string { return "UnsetKVReqValidationError" }

// Error satisfies the builtin error interface
func (e UnsetKVReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnsetKVReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnsetKVReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnsetKVReqValidationError{}

// Validate checks the field values on WatchReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WatchReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WatchReqMultiError, or nil
// if none found.
func (m *WatchReq) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetKeys()); l < 1 || l > 20 {
		err := WatchReqValidationError{
			field:  "Keys",
			reason: "value must contain between 1 and 20 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_WatchReq_Keys_Unique := make(map[string]struct{}, len(m.GetKeys()))

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if _, exists := _WatchReq_Keys_Unique[item]; exists {
			err := WatchReqValidationError{
				field:  fmt.Sprintf("Keys[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_WatchReq_Keys_Unique[item] = struct{}{}
		}

		// no validation rules for Keys[idx]
	}

	if len(errors) > 0 {
		return WatchReqMultiError(errors)
	}
	return nil
}

// WatchReqMultiError is an error wrapping multiple validation errors returned
// by WatchReq.ValidateAll() if the designated constraints aren't met.
type WatchReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchReqMultiError) AllErrors() []error { return m }

// WatchReqValidationError is the validation error returned by
// WatchReq.Validate if the designated constraints aren't met.
type WatchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchReqValidationError) ErrorName() string { return "WatchReqValidationError" }

// Error satisfies the builtin error interface
func (e WatchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchReqValidationError{}

// Validate checks the field values on TtlReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TtlReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TtlReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TtlReqMultiError, or nil if none found.
func (m *TtlReq) ValidateAll() error {
	return m.validate(true)
}

func (m *TtlReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		err := TtlReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.Contains(m.GetKey(), "/") {
		err := TtlReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TtlReqMultiError(errors)
	}
	return nil
}

// TtlReqMultiError is an error wrapping multiple validation errors returned by
// TtlReq.ValidateAll() if the designated constraints aren't met.
type TtlReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TtlReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TtlReqMultiError) AllErrors() []error { return m }

// TtlReqValidationError is the validation error returned by TtlReq.Validate if
// the designated constraints aren't met.
type TtlReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TtlReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TtlReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TtlReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TtlReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TtlReqValidationError) ErrorName() string { return "TtlReqValidationError" }

// Error satisfies the builtin error interface
func (e TtlReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTtlReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TtlReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TtlReqValidationError{}

// Validate checks the field values on TtlResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TtlResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TtlResp with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TtlRespMultiError, or nil if none found.
func (m *TtlResp) ValidateAll() error {
	return m.validate(true)
}

func (m *TtlResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ttl

	if len(errors) > 0 {
		return TtlRespMultiError(errors)
	}
	return nil
}

// TtlRespMultiError is an error wrapping multiple validation errors returned
// by TtlResp.ValidateAll() if the designated constraints aren't met.
type TtlRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TtlRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TtlRespMultiError) AllErrors() []error { return m }

// TtlRespValidationError is the validation error returned by TtlResp.Validate
// if the designated constraints aren't met.
type TtlRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TtlRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TtlRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TtlRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TtlRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TtlRespValidationError) ErrorName() string { return "TtlRespValidationError" }

// Error satisfies the builtin error interface
func (e TtlRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTtlResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TtlRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TtlRespValidationError{}

// Validate checks the field values on ExpireReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpireReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpireReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpireReqMultiError, or nil
// if none found.
func (m *ExpireReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpireReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		err := ExpireReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.Contains(m.GetKey(), "/") {
		err := ExpireReqValidationError{
			field:  "Key",
			reason: "value does not contain substring \"/\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExpireReqMultiError(errors)
	}
	return nil
}

// ExpireReqMultiError is an error wrapping multiple validation errors returned
// by ExpireReq.ValidateAll() if the designated constraints aren't met.
type ExpireReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpireReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpireReqMultiError) AllErrors() []error { return m }

// ExpireReqValidationError is the validation error returned by
// ExpireReq.Validate if the designated constraints aren't met.
type ExpireReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpireReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpireReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpireReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpireReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpireReqValidationError) ErrorName() string { return "ExpireReqValidationError" }

// Error satisfies the builtin error interface
func (e ExpireReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpireReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpireReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpireReqValidationError{}

// Validate checks the field values on RangeReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RangeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RangeReqMultiError, or nil
// if none found.
func (m *RangeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 2 {
		err := RangeReqValidationError{
			field:  "Key",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSeek() != "" {

		if utf8.RuneCountInString(m.GetSeek()) < 1 {
			err := RangeReqValidationError{
				field:  "Seek",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if val := m.GetLimit(); val < 1 || val > 100 {
		err := RangeReqValidationError{
			field:  "Limit",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RangeReqMultiError(errors)
	}
	return nil
}

// RangeReqMultiError is an error wrapping multiple validation errors returned
// by RangeReq.ValidateAll() if the designated constraints aren't met.
type RangeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeReqMultiError) AllErrors() []error { return m }

// RangeReqValidationError is the validation error returned by
// RangeReq.Validate if the designated constraints aren't met.
type RangeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeReqValidationError) ErrorName() string { return "RangeReqValidationError" }

// Error satisfies the builtin error interface
func (e RangeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeReqValidationError{}

// Validate checks the field values on RangeResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RangeResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RangeRespMultiError, or nil
// if none found.
func (m *RangeResp) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RangeRespValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RangeRespValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RangeRespValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for HasMore

	// no validation rules for NextSeekKey

	if len(errors) > 0 {
		return RangeRespMultiError(errors)
	}
	return nil
}

// RangeRespMultiError is an error wrapping multiple validation errors returned
// by RangeResp.ValidateAll() if the designated constraints aren't met.
type RangeRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeRespMultiError) AllErrors() []error { return m }

// RangeRespValidationError is the validation error returned by
// RangeResp.Validate if the designated constraints aren't met.
type RangeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeRespValidationError) ErrorName() string { return "RangeRespValidationError" }

// Error satisfies the builtin error interface
func (e RangeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeRespValidationError{}
